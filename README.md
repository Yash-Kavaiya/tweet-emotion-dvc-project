# tweet-emotion-dvc-project

Reference links

- Check out the documentation: <https://dvc.org/doc>
- Get help and share ideas: <https://dvc.org/chat>
- Star us on GitHub: <https://github.com/iterative/dvc>

DVC stage add
-n name
-d dependecy
-p parameters
-o outputs 
```
dvc stage add -n data_ingestion -d Code/data_ingestion.py -o data/raw python Code/data_ingestion.py 
```

YAML (YAML Ain't Markup Language) is a human-readable data serialization standard that is often used for configuration files and data exchange between languages with different data structures. It is designed to be easy to read and write, which makes it ideal for configuration files, data storage, and data transmission in various applications.

### Key Features of YAML

1. **Human Readability**: YAML is designed to be readable and writable by humans. It uses indentation and whitespace to define structure, similar to Python, which makes it easy to understand at a glance.
2. **Data Serialization**: YAML can represent data structures such as lists, dictionaries, and scalars (strings, numbers, booleans).
3. **Support for Complex Data Structures**: It can handle nested structures, allowing for complex configurations and data representations.
4. **Language Agnostic**: YAML can be used with multiple programming languages, including Python, Ruby, Perl, Java, and JavaScript.

### Syntax and Structure

#### Basic Elements

- **Scalars**: Scalars are single values, such as strings, numbers, or booleans.
  ```yaml
  string: "Hello, World!"
  integer: 25
  float: 3.14
  boolean: true
  ```

- **Lists**: Lists are ordered collections of items.
  ```yaml
  fruits:
    - Apple
    - Banana
    - Orange
  ```

- **Dictionaries**: Dictionaries (or mappings) are collections of key-value pairs.
  ```yaml
  person:
    name: John Doe
    age: 30
    email: johndoe@example.com
  ```

#### Advanced Elements

- **Nested Structures**: YAML supports nested lists and dictionaries.
  ```yaml
  company:
    name: Example Corp
    employees:
      - name: John Doe
        position: Developer
      - name: Jane Smith
        position: Designer
  ```

- **Multi-line Strings**: Multi-line strings can be written using `|` for a block scalar or `>` for a folded scalar.
  ```yaml
  block_scalar: |
    This is a block scalar.
    It can span multiple lines.
  folded_scalar: >
    This is a folded scalar.
    It also spans multiple lines,
    but newlines are folded into spaces.
  ```

- **Anchors and Aliases**: These allow for reusing pieces of data.
  ```yaml
  default: &default_settings
    database: localhost
    port: 3306

  development:
    <<: *default_settings
    database: devdb

  production:
    <<: *default_settings
    database: proddb
  ```

### Use Cases

1. **Configuration Files**: YAML is widely used for configuration files in various software, including Ansible, Kubernetes, and Docker.
   ```yaml
   version: '3'
   services:
     web:
       image: nginx
       ports:
         - "80:80"
   ```

2. **Data Serialization**: YAML can be used to serialize data structures for storage or transmission.
   ```yaml
   user:
     id: 123
     name: Alice
     roles:
       - admin
       - user
   ```

3. **API Definitions**: OpenAPI Specification (formerly known as Swagger) uses YAML to define RESTful APIs.
   ```yaml
   openapi: 3.0.0
   info:
     title: Sample API
     version: 1.0.0
   paths:
     /users:
       get:
         summary: List all users
         responses:
           '200':
             description: A list of users
   ```

### Parsing and Emitting YAML

YAML can be parsed and generated by various libraries in different programming languages. For example:

- **Python**: `PyYAML` library
  ```python
  import yaml

  data = yaml.safe_load(open('config.yaml'))
  print(data)
  ```

- **JavaScript**: `js-yaml` library
  ```javascript
  const yaml = require('js-yaml');
  const fs   = require('fs');

  try {
    const doc = yaml.load(fs.readFileSync('/path/to/file.yaml', 'utf8'));
    console.log(doc);
  } catch (e) {
    console.log(e);
  }
  ```

YAML's simplicity and readability make it a popular choice for configuration and data serialization tasks in various fields of software development and data management.

```
dvc repos
```

```
dvc stage add -n data_preprocessing -d Code/data_preprocessing.py -d data/raw -o data/processed python Code/data_preprocessing.py 
```

Logging in Python is a fundamental technique used to record events that occur during the execution of a program. It helps developers track the flow of execution, debug issues, and monitor the behavior of an application. Python provides a built-in logging module that facilitates logging operations with various levels of severity and customization options.

### Key Concepts in Logging:

1. **Logger**: The core component of the logging module is the `Logger` object. Loggers are used to generate log messages and manage their propagation through the logging hierarchy. Each logger is identified by a name, which is typically hierarchical using dot notation (e.g., `'app.module.function'`).

2. **Log Record**: When a logger generates a log message, it creates a `LogRecord` object that holds information about the event being logged. This includes the log message itself, the severity level, the timestamp, the logger name, and other contextual information.

3. **Handler**: Handlers are responsible for taking log records generated by loggers and sending them to their final destination, such as a file, console, or network socket. Python provides various built-in handlers (`StreamHandler`, `FileHandler`, `SocketHandler`, etc.) and allows custom handler implementations.

4. **Formatter**: Formatters determine the layout and content of log messages. They format the `LogRecord` objects into a string representation suitable for the chosen output destination. Formatters are attached to handlers and define how each log entry will look.

5. **Log Levels**: Log levels represent the severity of a log message. Python defines several standard log levels, including `DEBUG`, `INFO`, `WARNING`, `ERROR`, and `CRITICAL`, in increasing order of severity. Developers can choose the appropriate level based on the importance of the logged event.

### Basic Logging Example:

Here's a basic example demonstrating how to set up logging in Python:

```python
import logging

# Configure logging
logging.basicConfig(level=logging.DEBUG,  # Set the root logger level to DEBUG
                    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')

# Create a logger with a specific name
logger = logging.getLogger('my_app')

def main():
    try:
        # Perform some operations
        logger.debug('Debug message')    # Example debug message
        logger.info('Info message')      # Example info message
        logger.warning('Warning message')  # Example warning message
        logger.error('Error message')    # Example error message
        logger.critical('Critical message')  # Example critical message

        # Simulate an exception
        raise ValueError('Simulated error')
    except Exception as e:
        logger.error(f'Exception occurred: {str(e)}', exc_info=True)  # Log exception details

if __name__ == '__main__':
    main()
```

### Explanation:

- **Configuration**: `basicConfig()` is used to configure the root logger (`logging.basicConfig()`). Here, we set the logging level to `DEBUG`, which means all messages of severity `DEBUG` and higher (`INFO`, `WARNING`, `ERROR`, `CRITICAL`) will be processed.
  
- **Logger Creation**: `getLogger('my_app')` creates a logger named `'my_app'`. It's a good practice to use module-level loggers with names reflecting the module hierarchy (`__name__` is often used to automatically capture the current module name).

- **Logging Messages**: Various logging methods (`debug()`, `info()`, `warning()`, `error()`, `critical()`) are used to generate log messages with different severity levels. Each method corresponds to a standard log level.

- **Exception Logging**: `exc_info=True` in the `logger.error()` call allows logging of exception information (`traceback`) when an exception occurs.

### Best Practices:

- **Use Hierarchical Loggers**: Organize loggers hierarchically based on modules or components to manage logging more effectively.
  
- **Configurability**: Separate logging configuration from application code to enable easy adjustments in different environments (development, testing, production).

- **Logging Levels**: Choose appropriate logging levels (`DEBUG` for detailed debug information during development, `INFO` for general information, `WARNING` for potential issues, `ERROR` for errors that do not halt the program, `CRITICAL` for critical errors that require immediate attention).

- **Avoid Excessive Logging**: Be mindful of logging performance overhead. Use logging judiciously and focus on relevant information for troubleshooting and monitoring.

Logging in Python is versatile and can be customized extensively to suit different application needs. It provides a structured approach to monitoring application behavior and diagnosing issues, essential for maintaining robust and reliable software systems.